#! /usr/local/bin/python3
import gitlab
import itertools
import textwrap
import toml
import sys
import os
import argparse
import string

# * update
# * config
# * resolver
# * list --broken
# * new
# * add

# gl = gitlab.Gitlab('http://10.0.0.1')
gl = gitlab.Gitlab('https://gitlab.com')

# make an API request to create the gl.user object. This is mandatory if you
# use the username/password authentication.
# gl.auth()

# Get a single project by team/project name
project = gl.projects.get('simon.hudon/lean-depot')

# get all tags associated with the single project returned
tags = project.tags.list()
branches = project.branches.list()

# print(tags)
# print(branches)

if not os.path.exists('_depot'):
    os.system('git clone https://gitlab.com/simon.hudon/lean-depot.git/ _depot')

# gl = gitlab.Gitlab('https://gitlab.com/simon.hudon/lean-depot')
# p = gl.projects. .repositories.tags.list() # get('simon.hudon/lean-depot')
# # print(p.tags.get(id='snapshot-2019-10'))
# print(p)

l = {}

def user_command(name, parser = None):
    def decorator(func):
        l[name] = (func, parser)
        return func
    return decorator

def inline_table(d):
    res = toml.decoder.TomlDecoder()
    res = res.get_empty_inline_table()
    res.update(d)
    return res

def is_prefix_of(x,y):
    return x == y[:len(x)]

def snapshot_name(x):
    (base,ext) = os.path.splitext(x)
    if base == 'snapshot':
        return 'nightly'
    else:
        return base[len('snapshot')+1:]

def get_depot(vers):
    dir = os.getcwd()
    os.chdir(f'_depot/{vers}')
    try:
        os.system(f'git fetch --all')
        vs = { snapshot_name(v) : os.path.abspath(v)
                for v in os.listdir('.')
                if (os.path.splitext(v)[1] == '.toml'
                    and is_prefix_of('snapshot',v))}
        return vs

    finally:
        os.chdir(dir)

def load_snapshot(fn):
    def to_list(v):
        if isinstance(v, list): return v
        else: return [v]
    snap = toml.load(fn)
    snap = { git : { 'name': k, 'rev': v['rev'] }
             for (k,v) in snap['snapshot'].items()
             for git in to_list(v['git']) }
    return snap

@user_command('configure')
def configure():
    """setup leanpkg configuration"""

    prj = toml.load('lean-depot.toml')
    tag  = prj['package']['lib_snapshot']
    vers = prj['package']['lean_version']
    depot = toml.load(get_depot(vers)[tag])
    # print(depot)
    # print(prj)
    name         = prj['package']['name']
    lean_version = prj['package']['lean_version']
    snapshot = { v['git'] : v['rev'] for (k,v) in depot['snapshot'].items() }
    deps = { k : inline_table({ 'git' : v, 'rev' : snapshot[v] })
             for (k,v) in prj['dependencies'].items() }
    deps.update( prj['extra_deps'].items()  )
    leanpkg = { 'package' : { 'name' : name,
                              'lean_version' : lean_version,
                              'path' : 'src',
                              'version' : '0.1' },
                'dependencies' : deps }
    with open('leanpkg.toml', 'w') as h:
        h.write('# generated by lean-depot')
        h.write('#   * edit lean-depot.toml and not this file')
        h.write(toml.encoder.dumps(leanpkg, toml.encoder.TomlPreserveInlineDictEncoder()))
        h.write('# generated by lean-depot')
    os.system('leanpkg configure')

@user_command('init')
def init():
    """use latest snapshot"""
    leanpkg = toml.load(f'leanpkg.toml')
    name         = leanpkg['package']['name']
    lean_version = leanpkg['package']['lean_version']
    lean_version = str.split(lean_version,':')[-1]
    depot = get_depot(lean_version)
    if len(depot) <= 1:
        snapshot = 'nightly'
    else:
        snapshot = max(filter(lambda x: x != 'nightly', depot.keys()))
    all_deps = leanpkg['dependencies']
    deps = { k : v['git'] for (k,v) in all_deps.items()
             if 'git' in v }
    ext_deps =  { k : v for (k,v) in all_deps.items()
                      if 'git' not in v }
    prj = {}
    prj['package'] = { 'name' : name,
                       'lean_version' : lean_version,
                       'lib_snapshot' : snapshot }
    prj['dependencies'] = deps
    prj['extra_deps'] = ext_deps
    with open('lean-depot.toml', 'w') as h:
        h.write(toml.encoder.dumps(prj, toml.encoder.TomlPreserveInlineDictEncoder()))

@user_command('update')
def update():
    """use latest snapshot"""
    prj   = toml.load('lean-depot.toml')
    tag   = prj['package']['lib_snapshot']
    vers  = prj['package']['lean_version']
    deps  = prj['dependencies']
    depot = get_depot(vers)
    depot = [ (k, load_snapshot(v))
                  for (k,v) in depot.items() ]
                          # key=lambda x: x[0])
    depot = [ k
              for (k,v) in depot
              if len([ k2 for k2 in deps.values()
                       if k2 not in v ]) == 0 ]
    (x,depot) = (depot[0], depot[1:])
    if len(depot) == 0: snap = x
    else: snap = max(depot)
    prj['package']['lib_snapshot'] = snap
    with open('lean-depot.toml', 'w') as h:
        print(toml.encoder.dumps(prj, toml.encoder.TomlPreserveInlineDictEncoder()))
        h.write(toml.encoder.dumps(prj, toml.encoder.TomlPreserveInlineDictEncoder()))

@user_command('new')
def new():
    """create new package configuration"""
    print("not implemented")

@user_command('make_snapshot')
def make_snapshot():
    """create new package configuration"""
    pkg = toml.load('pkgs/mathlib.toml')['package']
    print(pkg)
    pkgs = { os.path.splitext(fn)[0] : toml.load(f'pkgs/{fn}')['package']
             for fn in os.listdir('pkgs')
             if os.path.splitext(fn)[1] == '.toml' }
    print(pkgs)

    snap = { 'snapshot' : { k : { 'git' : pkg['url'],
                                  'rev' : pkg['commit'],
                                  'desc' : pkg['description'] }
                                for (k,pkg) in pkgs.items() } }
    with open('snapshot/3.4.2/snapshot.toml', 'w') as h:
        print(toml.dump(snap, h))

@user_command('resolver')
def resolver():
    """find snapshots to accomodate all dependencies"""
    print("not implemented")

@user_command('list')
def list_packages():
    """list available packages"""
    prj   = toml.load('lean-depot.toml')
    tag   = prj['package']['lib_snapshot']
    vers  = prj['package']['lean_version']
    deps  = prj['dependencies']
    depot = toml.load(get_depot(vers)[tag])
    for (k,v) in depot['snapshot'].items():
        print(k)
        print("\n".join([ "  " + x for x in textwrap.wrap(v['desc'], 60)]))
        print('')

@user_command('snapshot')
def snapshot():
    """list available snapshots"""
    print("not implemented")

@user_command('nightly')
def nightly():
    """test package against nightly snapshot"""
    print("not implemented")

parser = argparse.ArgumentParser(description='Help about this command.')
parser.add_argument('cmd', choices=l.keys(), # required=False,
                    help='an integer for the accumulator')

@user_command('--help', parser)
def help(cmd):
    """provide this help screen"""
    usage()

def usage():
    w = max([ len(i) for i in l.keys() ])
    print(f'usage: {sys.argv[0]} [-h]')
    print('')
    print('Use currated set of Lean packages')
    print('')
    print('positional arguments:')
    for (k,v) in l.items():
        if k != '--help':
            print(f'  {str.ljust(k,w+3)}{v[0].__doc__}')

    print('')
    print('optional arguments:')
    print('  -h, --help  show this help message and exit')

if __name__ == '__main__':
    argv = sys.argv
    if len(argv) > 1 and argv[1] in l:
         (f,parser) = l[argv[1]]
         if parser:
             args = parser.parse_args(argv[2:])
             f(**args.__dict__)
         elif len(argv) == 2:
             f()
         else:
             usage()
    else:
        usage()

# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (begin (delete-file "~/.mathlib/bin/lean-depot") (copy-file (buffer-file-name) "~/.mathlib/bin/lean-depot" t))) nil t)
# End:
